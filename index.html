<!DOCTYPE html>
<html lang="fa">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ğŸ Ù†Ù‚Ø´Ù‡â€ŒÛŒ Ø¬Ø§ÛŒØ²Ù‡â€ŒÙ‡Ø§</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    *{box-sizing:border-box;direction:rtl}
    html,body{margin:0;padding:0;height:100%;font-family:'Vazirmatn',sans-serif;background:#0b1220;overflow:hidden;color:#fff}
    #map{height:100%;width:100%;filter:brightness(0.8) saturate(1.1)}
    #overlay{
      position:absolute;top:0;left:0;width:100%;height:100%;
      pointer-events:none;background:radial-gradient(circle at center,rgba(255,255,255,0.05),transparent 80%);
      opacity:0.25;
    }
    .hud{
      position:absolute;top:20px;left:50%;transform:translateX(-50%);
      display:flex;gap:12px;z-index:10;
    }
    .hud-item{
      background:rgba(255,255,255,0.08);
      border:1px solid rgba(255,255,255,0.1);
      padding:10px 18px;border-radius:16px;
      backdrop-filter:blur(8px);
      box-shadow:0 2px 10px rgba(0,0,0,0.4);
      font-size:15px;
      transition:all .3s ease;
    }
    .hud-item span{color:#00e6b8;font-weight:bold;font-size:17px;}
    .hud-item:hover{transform:scale(1.05);background:rgba(255,255,255,0.15)}

    /* container for bottom buttons to align buttons side-by-side */
    .bottom-actions {
      position: absolute;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 16px;
      z-index: 10;
    }

    .floating-btn{
      background:linear-gradient(135deg,#00e6b8,#0075ff);
      color:#fff;padding:14px 26px;border-radius:40px;
      font-size:16px;font-weight:600;border:none;cursor:pointer;
      box-shadow:0 6px 25px rgba(0,230,184,0.4);
      transition:all .3s ease;
      min-width:140px;
      display:inline-flex;align-items:center;justify-content:center;text-decoration:none;
    }
    .floating-btn:hover{transform:scale(1.05);box-shadow:0 8px 30px rgba(0,230,184,0.6);}

    /* disabled state for withdraw */
    .btn-disabled{
      opacity:0.45;
      pointer-events:none;
      filter:grayscale(0.1);
    }

    .modal{
      position:fixed;top:0;left:0;width:100%;height:100%;
      background:rgba(0,0,0,0.6);display:none;
      align-items:center;justify-content:center;z-index:999;
    }
    .card{
      background:rgba(15,22,40,0.9);
      border-radius:20px;
      padding:30px;
      text-align:center;
      box-shadow:0 10px 40px rgba(0,0,0,0.6);
      border:1px solid rgba(255,255,255,0.05);
      backdrop-filter:blur(10px);
      animation:pop .4s ease;
      max-width:350px;
    }
    @keyframes pop{0%{transform:scale(0.7);opacity:0}100%{transform:scale(1);opacity:1}}
    .card h2{margin-bottom:10px;color:#00e6b8}
    .card p{color:#ccc;margin-bottom:20px}
    .card button{background:linear-gradient(135deg,#00e6b8,#0075ff);border:none;color:#fff;padding:10px 20px;border-radius:8px;font-size:15px;cursor:pointer}
    .card button:hover{opacity:.9}

    /* Ù…ÙˆÙ‚Ø¹ÛŒØª Ú©Ø§Ø±Ø¨Ø± (Ø¯Ø§ÛŒØ±Ù‡ Ù†Ø¦ÙˆÙ†ÛŒ) */
    .user-marker {
      width: 18px; height: 18px;
      background: radial-gradient(circle, #00e6b8 30%, #0075ff 70%);
      border-radius: 50%;
      box-shadow: 0 0 15px 6px rgba(0,230,184,0.5);
      animation: pulse 2s infinite alternate;
      border: 2px solid #fff;
    }
    @keyframes pulse {
      from {transform: scale(1); box-shadow: 0 0 15px 6px rgba(0,230,184,0.5);}
      to {transform: scale(1.3); box-shadow: 0 0 25px 12px rgba(0,230,184,0.8);}
    }

    /* small responsive tweak */
    @media (max-width:520px){
      .floating-btn{padding:10px 14px;font-size:14px;min-width:110px}
      .hud{top:12px}
      .bottom-actions{gap:10px}
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="overlay"></div>

  <div class="hud">
    <div class="hud-item">Ù‚ÙÙ„â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²Ø´Ø¯Ù‡: <span id="count">0</span>/10</div>
    <div class="hud-item">Ù†Ø´Ø§Ù†Ú¯Ø±Ù‡Ø§: <span id="total">20</span></div>
  </div>

  <!-- bottom action buttons container -->
  <div class="bottom-actions" role="group" aria-label="actions">
    <button id="resetBtn" class="floating-btn">Reset</button>
    <!-- Withdraw starts as disabled (class btn-disabled); when enabled we remove that class and set href -->
    <a id="withdrawBtn" class="floating-btn btn-disabled" href="#" target="_blank" rel="noopener noreferrer" aria-disabled="true">Withdraw</a>
  </div>

  <div id="modal" class="modal">
    <div class="card">
      <h2>ğŸ‰ Ù‚ÙÙ„ Ø¨Ø§Ø² Ø´Ø¯!</h2>
      <p>Ø¢ÙØ±ÛŒÙ†! ÛŒÚ© Ù‚ÙÙ„ Ø¯ÛŒÚ¯Ø± Ø¨Ø§Ø² Ú©Ø±Ø¯ÛŒ.</p>
      <button id="closeModal">Ø§Ø¯Ø§Ù…Ù‡</button>
    </div>
  </div>

  <div id="winModal" class="modal">
    <div class="card">
      <h2>ğŸ† ØªØ¨Ø±ÛŒÚ©!</h2>
      <p>ØªÙˆ ØªÙˆÙ†Ø³ØªÛŒ Û±Û° Ù‚ÙÙ„ Ø±Ùˆ Ø¨Ø§Ø² Ú©Ù†ÛŒ!<br>Ù‡Ø¯ÛŒÙ‡â€ŒØ§Øª Ù…Ù†ØªØ¸Ø±ØªÙ‡ ğŸ’</p>
      <button onclick="window.location.reload()">Ø´Ø±ÙˆØ¹ Ø¯ÙˆØ¨Ø§Ø±Ù‡</button>
    </div>
  </div>

  <script>
    const map = L.map('map').setView([35.6892, 51.3890], 13);

    // MapTiler API
    L.tileLayer(`https://api.maptiler.com/maps/streets/{z}/{x}/{y}.png?key=wtyVynedWDK2q9aMHfGI`, {
      attribution: '&copy; <a href="https://www.maptiler.com/">MapTiler</a> & <a href="https://www.openstreetmap.org/">OpenStreetMap</a>',
    }).addTo(map);

    let markers = [], unlockedIds = JSON.parse(localStorage.getItem("unlockedMarkers") || "[]"), userMarker, userCircle;

    const WITHDRAW_TG = "https://t.me/Whale_Armin";
    const withdrawBtn = document.getElementById("withdrawBtn");
    const resetBtn = document.getElementById("resetBtn");

    function randomPoints(n){
      markers.forEach(m=>m.remove?.()); markers = [];
      const center = map.getCenter();
      const latRange = 0.05, lngRange = 0.05;
      for (let i = 0; i < n; i++){
        const lat = center.lat + (Math.random()-0.5)*latRange;
        const lng = center.lng + (Math.random()-0.5)*lngRange;
        const id = `${lat.toFixed(5)},${lng.toFixed(5)}`;
        const color = unlockedIds.includes(id) ? "#00e6b8" : "#ffd27a";
        const marker = L.circleMarker([lat,lng], {radius:10, color:color, fillColor:color, fillOpacity:0.9});
        marker.id = id;
        marker.addTo(map);
        markers.push(marker);
      }
      document.getElementById("total").innerText = n;
      document.getElementById("count").innerText = unlockedIds.length;
      updateWithdrawState();
    }

    randomPoints(20);

    function distance(lat1, lon1, lat2, lon2){
      const R = 6371e3;
      const Ï†1 = lat1*Math.PI/180, Ï†2 = lat2*Math.PI/180;
      const Î”Ï† = (lat2-lat1)*Math.PI/180;
      const Î”Î» = (lon2-lon1)*Math.PI/180;
      const a = Math.sin(Î”Ï†/2)**2 + Math.cos(Ï†1)*Math.cos(Ï†2)*Math.sin(Î”Î»/2)**2;
      return R*2*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }

    function updateUserLocation(pos){
      const lat = pos.coords.latitude;
      const lng = pos.coords.longitude;

      if(!userMarker){
        const icon = L.divIcon({className:'user-marker'});
        userMarker = L.marker([lat,lng],{icon}).addTo(map);
        userCircle = L.circle([lat,lng],{radius:50, color:'#00e6b8', fillColor:'#00e6b8', fillOpacity:0.1}).addTo(map);
      } else {
        userMarker.setLatLng([lat,lng]);
        userCircle.setLatLng([lat,lng]);
      }

      markers.forEach(marker=>{
        if(!unlockedIds.includes(marker.id)){
          const dist = distance(lat,lng, marker.getLatLng().lat, marker.getLatLng().lng);
          if(dist<50){
            marker.setStyle({color:'#00e6b8', fillColor:'#00e6b8'});
            unlockedIds.push(marker.id);
            localStorage.setItem("unlockedMarkers", JSON.stringify(unlockedIds));
            document.getElementById("count").innerText = unlockedIds.length;
            updateWithdrawState();
            showModal("#modal");
            if (unlockedIds.length >= 10) setTimeout(()=>showModal("#winModal"),700);
          }
        }
      });
    }

    function showModal(sel){
      const el = document.querySelector(sel);
      el.style.display='flex';
      el.querySelector('button').addEventListener('click',()=>el.style.display='none',{once:true});
    }

    // Enable or disable withdraw button depending on unlocked count
    function updateWithdrawState(){
      if (unlockedIds.length >= 10) {
        withdrawBtn.classList.remove('btn-disabled');
        withdrawBtn.setAttribute('href', WITHDRAW_TG);
        withdrawBtn.setAttribute('aria-disabled','false');
      } else {
        withdrawBtn.classList.add('btn-disabled');
        withdrawBtn.setAttribute('href', '#');
        withdrawBtn.setAttribute('aria-disabled','true');
      }
    }

    // Reset button behavior
    resetBtn.addEventListener("click",()=>{
      localStorage.removeItem("unlockedMarkers");
      unlockedIds = [];
      randomPoints(20);
      // also remove user progress count display
      document.getElementById("count").innerText = 0;
    });

    // Withdraw button behavior - only when enabled (we still guard click)
    withdrawBtn.addEventListener("click",(e)=>{
      if (withdrawBtn.classList.contains('btn-disabled')) {
        // do nothing at all (no text, no alert)
        e.preventDefault();
        return;
      }
      // allow navigation to telegram in a new tab (anchor already has href)
      // no extra dialogs shown
    });

    // Start geolocation watch only on a real user gesture to ensure browser shows permission.
    if (navigator.geolocation){
      function startGeoOnUserGesture(){
        navigator.geolocation.getCurrentPosition(pos=>{
          // start watching after permission granted
          navigator.geolocation.watchPosition(updateUserLocation,
            ()=>{/* silently ignore or user sees browser error */},
            {enableHighAccuracy:true});
        }, err=>{
          // permission denied or other error: we silently ignore (per your request)
        });
        window.removeEventListener('click', startGeoOnUserGesture);
      }
      window.addEventListener('click', startGeoOnUserGesture);
    } else {
      alert("Ù…Ø±ÙˆØ±Ú¯Ø± Ø´Ù…Ø§ Ø§Ø² Ù…ÙˆÙ‚Ø¹ÛŒØªâ€ŒÛŒØ§Ø¨ÛŒ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ù†Ù…ÛŒâ€ŒÚ©Ù†Ø¯.");
    }
  </script>
</body>
</html>}
.menu {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.9);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 100;
}
.hide {
    display: none !important;
}
h1 {
    color: white;
    font-size: 48px;
    margin: 20px;
    text-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
    animation: pulse 2s ease-in-out infinite;
}
@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}
button {
    padding: 15px 40px;
    font-size: 24px;
    background: linear-gradient(135deg, #e74c3c, #c0392b);
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    margin: 10px;
}
button:hover {
    background: linear-gradient(135deg, #c0392b, #a93226);
}
#info {
    position: absolute;
    top: 10px;
    left: 10px;
    background: rgba(0, 0, 0, 0.7);
    padding: 10px;
    border-radius: 8px;
    color: white;
    font-size: 14px;
    z-index: 10;
    backdrop-filter: blur(5px);
}
#hpBar {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(0, 0, 0, 0.7);
    padding: 10px;
    border-radius: 8px;
    z-index: 10;
    backdrop-filter: blur(5px);
}
#hpFill {
    width: 120px;
    height: 10px;
    background: #333;
    border-radius: 5px;
    overflow: hidden;
}
#hpInner {
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, #2ecc71, #f1c40f, #e74c3c);
    transition: width 0.3s;
}
.joystick {
    position: absolute;
    bottom: 80px;
    width: 110px;
    height: 110px;
    background: rgba(0, 0, 0, 0.4);
    border: 3px solid rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    z-index: 20;
}
#leftJoy {
    left: 40px;
}
#rightJoy {
    right: 40px;
}
.stick {
    width: 45px;
    height: 45px;
    background: radial-gradient(circle, #3498db, #2980b9);
    border: 3px solid white;
    border-radius: 50%;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    box-shadow: 0 0 15px rgba(52, 152, 219, 0.6);
    touch-action: none;
}
#rightJoy .stick {
    background: radial-gradient(circle, #e74c3c, #c0392b);
    box-shadow: 0 0 15px rgba(231, 76, 60, 0.6);
}
</style>
</head>
<body>
<div id="gameBox">
    <canvas id="canvas"></canvas>
    
    <div id="startMenu" class="menu">
        <h1>ğŸ¯ Ø¨Ø§Ø²ÛŒ ØªÛŒØ±Ø§Ù†Ø¯Ø§Ø²ÛŒ</h1>
        <p style="color:#ccc;margin:20px;text-align:center;padding:0 20px">
            Ø¬ÙˆÛŒ Ø§Ø³ØªÛŒÚ© Ú†Ù¾: Ø­Ø±Ú©Øª | Ø¬ÙˆÛŒ Ø§Ø³ØªÛŒÚ© Ø±Ø§Ø³Øª: Ø´Ù„ÛŒÚ©<br>
            Ø¯Ø³Ú©ØªØ§Ù¾: WASD Ø­Ø±Ú©Øª | Ù…ÙˆØ³ Ù†Ø´Ø§Ù†Ù‡â€ŒÚ¯ÛŒØ±ÛŒ | Ú©Ù„ÛŒÚ© Ø´Ù„ÛŒÚ©<br>
            ğŸ’š Ø¨Ø§Ù†Ø¯Ø§Ú˜: Ù‡Ø± 6 Ø«Ø§Ù†ÛŒÙ‡ +10 HP
        </p>
        <button onclick="gameStart()">Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²ÛŒ</button>
    </div>
    
    <div id="endMenu" class="menu hide">
        <h1>ğŸ’€ Ø¨Ø§Ø²ÛŒ ØªÙ…Ø§Ù… Ø´Ø¯!</h1>
        <p style="color:#f1c40f;font-size:28px;margin:15px">
            Ø§Ù…ØªÛŒØ§Ø²: <span id="finalScore">0</span>
        </p>
        <p style="color:#2ecc71;font-size:24px;margin:10px">
            Ù¾ÙˆÙ„: <span id="finalMoney">0</span>
        </p>
        <p style="color:#9b59b6;font-size:24px;margin:10px">
            Ù…Ø±Ø­Ù„Ù‡: <span id="finalWave">1</span>
        </p>
        <button onclick="gameStart()">Ø¨Ø§Ø²ÛŒ Ø¯ÙˆØ¨Ø§Ø±Ù‡</button>
    </div>
    
    <div id="info" class="hide">
        <div style="color:#f1c40f">Ø§Ù…ØªÛŒØ§Ø²: <span id="scoreVal">0</span></div>
        <div style="color:#2ecc71">Ù¾ÙˆÙ„: <span id="moneyVal">0</span></div>
        <div style="color:#9b59b6">Ù…ÙˆØ¬: <span id="waveVal">1</span></div>
        <button onclick="upgradeWeapon()" id="upgradeBtn" style="padding:6px 12px;font-size:12px;margin-top:5px">
            Ø§Ø±ØªÙ‚Ø§ (100)
        </button>
    </div>
    
    <div id="hpBar" class="hide">
        <div id="hpFill">
            <div id="hpInner"></div>
        </div>
        <div style="text-align:center;color:white;margin-top:3px;font-size:12px">
            <span id="hpText">100</span>/100
        </div>
    </div>
    
    <div id="leftJoy" class="joystick hide">
        <div class="stick" id="leftStick"></div>
    </div>
    
    <div id="rightJoy" class="joystick hide">
        <div class="stick" id="rightStick"></div>
    </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let W, H, state = 'menu';
let score = 0, money = 0, health = 100, gunLvl = 1, waveNum = 1, killCount = 0, bossActive = false;
let playerX, playerY, velX = 0, velY = 0, aimDirX = 0, aimDirY = -1, aiming = false;
let enemyList = [], bulletList = [], enemyBulletList = [], particleList = [], bandageList = [], boss = null;
let lastShot = 0, lastSpawn = 0, lastBandage = 0, screenShake = 0;
let keyPressed = {}, audioCtx = null;

const weaponData = {
    1: { damage: 25, speed: 9, fireRate: 250, cost: 0, bullets: 1 },
    2: { damage: 40, speed: 11, fireRate: 200, cost: 100, bullets: 1 },
    3: { damage: 60, speed: 13, fireRate: 150, cost: 250, bullets: 2 },
    4: { damage: 100, speed: 16, fireRate: 100, cost: 500, bullets: 2 },
    5: { damage: 150, speed: 18, fireRate: 80, cost: 1000, bullets: 2 }
};

function resizeCanvas() {
    const box = document.getElementById('gameBox');
    W = canvas.width = box.clientWidth;
    H = canvas.height = box.clientHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

function playAudio(soundType) {
    try {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        const t = audioCtx.currentTime;
        
        switch(soundType) {
            case 'shoot':
                osc.frequency.value = 400;
                osc.type = 'square';
                gain.gain.setValueAtTime(0.1, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                osc.start(t);
                osc.stop(t + 0.1);
                break;
            case 'hit':
                osc.frequency.value = 200;
                osc.type = 'sawtooth';
                gain.gain.setValueAtTime(0.12, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
                osc.start(t);
                osc.stop(t + 0.15);
                break;
            case 'kill':
                osc.frequency.value = 100;
                osc.type = 'sawtooth';
                gain.gain.setValueAtTime(0.15, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
                osc.start(t);
                osc.stop(t + 0.3);
                break;
            case 'damage':
                osc.frequency.value = 150;
                osc.type = 'triangle';
                gain.gain.setValueAtTime(0.15, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
                osc.start(t);
                osc.stop(t + 0.2);
                break;
            case 'heal':
                osc.frequency.value = 600;
                osc.type = 'sine';
                gain.gain.setValueAtTime(0.12, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.25);
                osc.start(t);
                osc.stop(t + 0.25);
                break;
            case 'upgrade':
                [400, 500, 600].forEach((freq, i) => {
                    const o = audioCtx.createOscillator();
                    const g = audioCtx.createGain();
                    o.connect(g);
                    g.connect(audioCtx.destination);
                    o.frequency.value = freq;
                    o.type = 'sine';
                    const time = t + i * 0.1;
                    g.gain.setValueAtTime(0.1, time);
                    g.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
                    o.start(time);
                    o.stop(time + 0.2);
                });
                break;
        }
    } catch(e) {}
}

function addParticles(x, y, color, count = 10) {
    for (let i = 0; i < count; i++) {
        const angle = (Math.PI * 2 * i) / count;
        particleList.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * (2 + Math.random() * 3),
            vy: Math.sin(angle) * (2 + Math.random() * 3),
            life: 1,
            color: color,
            size: 3 + Math.random() * 3
        });
    }
}

function drawParticles() {
    for (let i = particleList.length - 1; i >= 0; i--) {
        const p = particleList[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vx *= 0.95;
        p.vy *= 0.95;
        p.life -= 0.02;
        
        if (p.life <= 0) {
            particleList.splice(i, 1);
            continue;
        }
        
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.globalAlpha = 1;
}

window.addEventListener('keydown', e => keyPressed[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keyPressed[e.key.toLowerCase()] = false);

canvas.addEventListener('mousemove', e => {
    if (state !== 'play') return;
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const dx = mx - playerX;
    const dy = my - playerY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist > 0) {
        aimDirX = dx / dist;
        aimDirY = dy / dist;
        aiming = true;
    }
});

canvas.addEventListener('click', () => {
    if (state === 'play') shootBullet();
});

let leftTouchId = null, leftActive = false;
const leftStick = document.getElementById('leftStick');
const leftJoy = document.getElementById('leftJoy');

leftJoy.addEventListener('touchstart', e => {
    if (state !== 'play') return;
    e.preventDefault();
    leftTouchId = e.changedTouches[0].identifier;
    leftActive = true;
}, {passive: false});

leftJoy.addEventListener('touchmove', e => {
    if (!leftActive || state !== 'play') return;
    e.preventDefault();
    
    let touch = null;
    for (let t of e.touches) {
        if (t.identifier === leftTouchId) {
            touch = t;
            break;
        }
    }
    if (!touch) return;
    
    const rect = leftJoy.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    const dx = touch.clientX - centerX;
    const dy = touch.clientY - centerY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const maxDist = 30;
    
    if (dist > maxDist) {
        const angle = Math.atan2(dy, dx);
        leftStick.style.left = `calc(50% + ${Math.cos(angle) * maxDist}px)`;
        leftStick.style.top = `calc(50% + ${Math.sin(angle) * maxDist}px)`;
        velX = Math.cos(angle) * 4;
        velY = Math.sin(angle) * 4;
    } else {
        leftStick.style.left = `calc(50% + ${dx}px)`;
        leftStick.style.top = `calc(50% + ${dy}px)`;
        velX = (dx / maxDist) * 4;
        velY = (dy / maxDist) * 4;
    }
}, {passive: false});

leftJoy.addEventListener('touchend', e => {
    if (!leftActive) return;
    e.preventDefault();
    for (let t of e.changedTouches) {
        if (t.identifier === leftTouchId) {
            leftActive = false;
            leftTouchId = null;
            leftStick.style.left = '50%';
            leftStick.style.top = '50%';
            velX = 0;
            velY = 0;
            break;
        }
    }
}, {passive: false});

leftJoy.addEventListener('touchcancel', e => {
    if (!leftActive) return;
    e.preventDefault();
    for (let t of e.changedTouches) {
        if (t.identifier === leftTouchId) {
            leftActive = false;
            leftTouchId = null;
            leftStick.style.left = '50%';
            leftStick.style.top = '50%';
            velX = 0;
            velY = 0;
            break;
        }
    }
}, {passive: false});

let rightTouchId = null, rightActive = false;
const rightStick = document.getElementById('rightStick');
const rightJoy = document.getElementById('rightJoy');

rightJoy.addEventListener('touchstart', e => {
    if (state !== 'play') return;
    e.preventDefault();
    rightTouchId = e.changedTouches[0].identifier;
    rightActive = true;
    aiming = true;
}, {passive: false});

rightJoy.addEventListener('touchmove', e => {
    if (!rightActive || state !== 'play') return;
    e.preventDefault();
    
    let touch = null;
    for (let t of e.touches) {
        if (t.identifier === rightTouchId) {
            touch = t;
            break;
        }
    }
    if (!touch) return;
    
    const rect = rightJoy.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    const dx = touch.clientX - centerX;
    const dy = touch.clientY - centerY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const maxDist = 30;
    
    if (dist > 5) {
        if (dist > maxDist) {
            const angle = Math.atan2(dy, dx);
            rightStick.style.left = `calc(50% + ${Math.cos(angle) * maxDist}px)`;
            rightStick.style.top = `calc(50% + ${Math.sin(angle) * maxDist}px)`;
            aimDirX = Math.cos(angle);
            aimDirY = Math.sin(angle);
        } else {
            rightStick.style.left = `calc(50% + ${dx}px)`;
            rightStick.style.top = `calc(50% + ${dy}px)`;
            const angle = Math.atan2(dy, dx);
            aimDirX = Math.cos(angle);
            aimDirY = Math.sin(angle);
        }
    }
}, {passive: false});

rightJoy.addEventListener('touchend', e => {
    if (!rightActive) return;
    e.preventDefault();
    for (let t of e.changedTouches) {
        if (t.identifier === rightTouchId) {
            rightActive = false;
            rightTouchId = null;
            rightStick.style.left = '50%';
            rightStick.style.top = '50%';
            aiming = false;
            break;
        }
    }
}, {passive: false});

rightJoy.addEventListener('touchcancel', e => {
    if (!rightActive) return;
    e.preventDefault();
    for (let t of e.changedTouches) {
        if (t.identifier === rightTouchId) {
            rightActive = false;
            rightTouchId = null;
            rightStick.style.left = '50%';
            rightStick.style.top = '50%';
            aiming = false;
            break;
        }
    }
}, {passive: false});

function shootBullet() {
    if (!aiming) return;
    const now = Date.now();
    if (now - lastShot < weaponData[gunLvl].fireRate) return;
    
    lastShot = now;
    
    const numBullets = weaponData[gunLvl].bullets;
    const aimBot = gunLvl >= 5;
    
    if (numBullets === 1) {
        let finalAimX = aimDirX;
        let finalAimY = aimDirY;
        
        if (aimBot && enemyList.length > 0) {
            let closest = enemyList[0];
            let minDist = Infinity;
            for (let e of enemyList) {
                const dx = e.x - playerX;
                const dy = e.y - playerY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < minDist) {
                    minDist = dist;
                    closest = e;
                }
            }
            const dx = closest.x - playerX;
            const dy = closest.y - playerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            finalAimX = dx / dist;
            finalAimY = dy / dist;
        }
        
        bulletList.push({
            x: playerX,
            y: playerY,
            vx: finalAimX * weaponData[gunLvl].speed,
            vy: finalAimY * weaponData[gunLvl].speed,
            dmg: weaponData[gunLvl].damage
        });
    } else {
        const spread = 0.3;
        for (let i = 0; i < numBullets; i++) {
            const offset = (i - (numBullets - 1) / 2) * spread;
            let finalAimX = aimDirX;
            let finalAimY = aimDirY;
            
            if (aimBot && enemyList.length > i) {
                const target = enemyList[i % enemyList.length];
                const dx = target.x - playerX;
                const dy = target.y - playerY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                finalAimX = dx / dist;
                finalAimY = dy / dist;
            }
            
            const angle = Math.atan2(finalAimY, finalAimX) + offset;
            bulletList.push({
                x: playerX,
                y: playerY,
                vx: Math.cos(angle) * weaponData[gunLvl].speed,
                vy: Math.sin(angle) * weaponData[gunLvl].speed,
                dmg: weaponData[gunLvl].damage
            });
        }
    }
    
    playAudio('shoot');
    addParticles(playerX + aimDirX * 25, playerY + aimDirY * 25, '#f1c40f', 5);
    screenShake = 3;
}

function upgradeWeapon() {
    if (gunLvl < 5 && money >= weaponData[gunLvl + 1].cost) {
        money -= weaponData[gunLvl + 1].cost;
        gunLvl++;
        playAudio('upgrade');
        addParticles(W - 60, 40, '#f39c12', 15);
        updateDisplay();
    }
}

function updateDisplay() {
    document.getElementById('scoreVal').textContent = score;
    document.getElementById('moneyVal').textContent = money;
    document.getElementById('waveVal').textContent = waveNum;
    document.getElementById('hpInner').style.width = (health * 100 / 100) + '%';
    document.getElementById('hpText').textContent = Math.floor(health);
    
    const btn = document.getElementById('upgradeBtn');
    if (gunLvl < 5) {
        btn.textContent = 'Ø§Ø±ØªÙ‚Ø§ (' + weaponData[gunLvl + 1].cost + ')';
        btn.disabled = money < weaponData[gunLvl + 1].cost;
    } else {
        btn.textContent = 'Ø­Ø¯Ø§Ú©Ø«Ø±';
        btn.disabled = true;
    }
}

function gameStart() {
    state = 'play';
    score = 0;
    money = 0;
    health = 100;
    gunLvl = 1;
    waveNum = 1;
    killCount = 0;
    bossActive = false;
    boss = null;
    enemyList = [];
    bulletList = [];
    enemyBulletList = [];
    particleList = [];
    bandageList = [];
    playerX = W / 2;
    playerY = H / 2;
    velX = 0;
    velY = 0;
    aimDirX = 0;
    aimDirY = -1;
    aiming = false;
    screenShake = 0;
    lastShot = 0;
    lastSpawn = 0;
    lastBandage = 0;
    
    document.getElementById('startMenu').classList.add('hide');
    document.getElementById('endMenu').classList.add('hide');
    document.getElementById('info').classList.remove('hide');
    document.getElementById('hpBar').classList.remove('hide');
    document.getElementById('leftJoy').classList.remove('hide');
    document.getElementById('rightJoy').classList.remove('hide');
    
    updateDisplay();
    gameLoop();
}

function gameOver() {
    state = 'end';
    playAudio('damage');
    addParticles(playerX, playerY, '#3498db', 30);
    
    document.getElementById('finalScore').textContent = score;
    document.getElementById('finalMoney').textContent = money;
    document.getElementById('finalWave').textContent = waveNum;
    document.getElementById('endMenu').classList.remove('hide');
    document.getElementById('info').classList.add('hide');
    document.getElementById('hpBar').classList.add('hide');
    document.getElementById('leftJoy').classList.add('hide');
    document.getElementById('rightJoy').classList.add('hide');
}

function gameLoop(timestamp = 0) {
    if (state !== 'play') return;
    
    let shakeX = 0, shakeY = 0;
    if (screenShake > 0) {
        shakeX = (Math.random() - 0.5) * screenShake;
        shakeY = (Math.random() - 0.5) * screenShake;
        screenShake *= 0.9;
        if (screenShake < 0.1) screenShake = 0;
    }
    
    ctx.save();
    ctx.translate(shakeX, shakeY);
    ctx.clearRect(-shakeX, -shakeY, W, H);
    
    if (keyPressed['w'] || keyPressed['Øµ']) velY = -4;
    else if (keyPressed['s'] || keyPressed['Ø³']) velY = 4;
    else if (!leftActive) velY = 0;
    
    if (keyPressed['a'] || keyPressed['Ø´']) velX = -4;
    else if (keyPressed['d'] || keyPressed['ÛŒ']) velX = 4;
    else if (!leftActive) velX = 0;
    
    playerX += velX;
    playerY += velY;
    playerX = Math.max(20, Math.min(W - 20, playerX));
    playerY = Math.max(20, Math.min(H - 20, playerY));
    
    if (rightActive) shootBullet();
    
    // Spawn bandages
    if (timestamp - lastBandage > 6000) {
        const x = Math.random() * (W - 100) + 50;
        const y = Math.random() * (H - 100) + 50;
        bandageList.push({ x: x, y: y, pulse: 0 });
        lastBandage = timestamp;
    }
    
    // Draw bandages
    for (let i = bandageList.length - 1; i >= 0; i--) {
        const bandage = bandageList[i];
        bandage.pulse += 0.05;
        const pulseSize = Math.sin(bandage.pulse) * 3;
        
        ctx.fillStyle = '#2ecc71';
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#2ecc71';
        ctx.beginPath();
        ctx.arc(bandage.x, bandage.y, 10 + pulseSize, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(bandage.x - 6, bandage.y);
        ctx.lineTo(bandage.x + 6, bandage.y);
        ctx.moveTo(bandage.x, bandage.y - 6);
        ctx.lineTo(bandage.x, bandage.y + 6);
        ctx.stroke();
        ctx.shadowBlur = 0;
        
        const dx = bandage.x - playerX;
        const dy = bandage.y - playerY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < 30) {
            health = Math.min(100, health + 10);
            playAudio('heal');
            addParticles(bandage.x, bandage.y, '#2ecc71', 15);
            updateDisplay();
            bandageList.splice(i, 1);
        }
    }
    
    // Boss spawn check
    if (waveNum % 5 === 0 && !bossActive && enemyList.length === 0 && !boss) {
        bossActive = true;
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.max(W, H) * 0.8;
        boss = {
            x: playerX + Math.cos(angle) * distance,
            y: playerY + Math.sin(angle) * distance,
            hp: 500 + waveNum * 100,
            maxHp: 500 + waveNum * 100,
            speed: 0.5,
            angle: 0,
            lastShot: 0,
            gears: []
        };
        
        // Create gears around boss
        for (let i = 0; i < 6; i++) {
            boss.gears.push({
                angle: (Math.PI * 2 * i) / 6,
                rotation: 0
            });
        }
        
        // Boss announcement
        ctx.save();
        ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
        ctx.fillRect(0, 0, W, H);
        ctx.fillStyle = '#ff0000';
        ctx.font = 'bold 48px Tahoma';
        ctx.textAlign = 'center';
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#ff0000';
        ctx.fillText('âš ï¸ Ø¨Ø§Ø³ Ù…Ø±Ø­Ù„Ù‡ ' + waveNum + ' âš ï¸', W / 2, H / 2);
        ctx.restore();
    }
    
    // Update boss
    if (boss) {
        const dx = playerX - boss.x;
        const dy = playerY - boss.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 50) {
            boss.x += (dx / distance) * boss.speed;
            boss.y += (dy / distance) * boss.speed;
        }
        
        boss.angle += 0.02;
        
        // Boss shooting
        const now = Date.now();
        if (now - boss.lastShot > 3000) {
            boss.lastShot = now;
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 * i) / 8;
                enemyBulletList.push({
                    x: boss.x,
                    y: boss.y,
                    vx: Math.cos(angle) * 3,
                    vy: Math.sin(angle) * 3
                });
            }
            addParticles(boss.x, boss.y, '#ff00ff', 20);
        }
        
        // Check bullet collision with boss
        for (let i = bulletList.length - 1; i >= 0; i--) {
            const bullet = bulletList[i];
            const bdx = bullet.x - boss.x;
            const bdy = bullet.y - boss.y;
            const bdist = Math.sqrt(bdx * bdx + bdy * bdy);
            
            if (bdist < 40) {
                boss.hp -= bullet.dmg;
                bulletList.splice(i, 1);
                playAudio('hit');
                addParticles(boss.x, boss.y, '#ff00ff', 12);
                screenShake = 3;
                
                if (boss.hp <= 0) {
                    score += 100;
                    money += 50;
                    playAudio('kill');
                    addParticles(boss.x, boss.y, '#ff00ff', 40);
                    screenShake = 10;
                    boss = null;
                    bossActive = false;
                    killCount = 0;
                    waveNum++;
                    updateDisplay();
                }
            }
        }
        
        // Check gear collision with player
        if (boss) {
            for (let gear of boss.gears) {
                gear.rotation += 0.1;
                const gx = boss.x + Math.cos(gear.angle + boss.angle) * 60;
                const gy = boss.y + Math.sin(gear.angle + boss.angle) * 60;
                const gdx = gx - playerX;
                const gdy = gy - playerY;
                const gdist = Math.sqrt(gdx * gdx + gdy * gdy);
                
                if (gdist < 35) {
                    health -= 5;
                    screenShake = 8;
                    
                    ctx.save();
                    ctx.globalAlpha = 0.4;
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(0, 0, W, H);
                    ctx.restore();
                    
                    updateDisplay();
                    if (health <= 0) {
                        gameOver();
                    }
                }
            }
        }
        
        // Draw boss
        if (boss) {
            // Boss body
            const gradient = ctx.createRadialGradient(boss.x, boss.y, 10, boss.x, boss.y, 40);
            gradient.addColorStop(0, '#ff00ff');
            gradient.addColorStop(1, '#8b008b');
            
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ff00ff';
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(boss.x, boss.y, 40, 0, Math.PI * 2);
            ctx.fill();
            
            // Boss eyes
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(boss.x - 12, boss.y - 8, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(boss.x + 12, boss.y - 8, 6, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#f00';
            ctx.beginPath();
            ctx.arc(boss.x - 12 + (dx / distance) * 3, boss.y - 8 + (dy / distance) * 3, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(boss.x + 12 + (dx / distance) * 3, boss.y - 8 + (dy / distance) * 3, 3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.shadowBlur = 0;
            
            // Draw gears
            for (let gear of boss.gears) {
                const gx = boss.x + Math.cos(gear.angle + boss.angle) * 60;
                const gy = boss.y + Math.sin(gear.angle + boss.angle) * 60;
                
                ctx.save();
                ctx.translate(gx, gy);
                ctx.rotate(gear.rotation);
                
                ctx.fillStyle = '#444';
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 2;
                
                ctx.beginPath();
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 * i) / 8;
                    const r = i % 2 === 0 ? 18 : 12;
                    const x = Math.cos(angle) * r;
                    const y = Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.fillStyle = '#666';
                ctx.beginPath();
                ctx.arc(0, 0, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                ctx.restore();
            }
            
            // Boss health bar
            ctx.fillStyle = '#333';
            ctx.fillRect(boss.x - 50, boss.y - 55, 100, 5);
            ctx.fillStyle = '#ff00ff';
            ctx.fillRect(boss.x - 50, boss.y - 55, 100 * (boss.hp / boss.maxHp), 5);
            
            // Boss HP text
            ctx.fillStyle = '#fff';
            ctx.font = '12px Tahoma';
            ctx.textAlign = 'center';
            ctx.fillText('Ø¨Ø§Ø³: ' + Math.floor(boss.hp) + '/' + boss.maxHp, boss.x, boss.y - 60);
        }
    }
    
    // Spawn normal enemies (not during boss fight)
    if (!bossActive) {
        const maxEnemies = Math.min(4 + Math.floor(waveNum / 3) * 2, 12);
        if (enemyList.length < maxEnemies && timestamp - lastSpawn > Math.max(800 - waveNum * 30, 300)) {
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.max(W, H) * 0.7;
            const canShoot = waveNum >= 5 && Math.random() < 0.33;
            enemyList.push({
                x: playerX + Math.cos(angle) * distance,
                y: playerY + Math.sin(angle) * distance,
                hp: 25 + waveNum * 8,
                maxHp: 25 + waveNum * 8,
                speed: Math.min(1.0 + waveNum * 0.08, 2.5),
                canShoot: canShoot,
                lastShot: 0,
                angle: 0
            });
            lastSpawn = timestamp;
        }
    }
    
    bulletList = bulletList.filter(b => {
        b.x += b.vx;
        b.y += b.vy;
        
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#f1c40f';
        ctx.fillStyle = '#f1c40f';
        ctx.beginPath();
        ctx.arc(b.x, b.y, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        
        return b.x > -50 && b.x < W + 50 && b.y > -50 && b.y < H + 50;
    });
    
    enemyList = enemyList.filter(enemy => {
        const dx = playerX - enemy.x;
        const dy = playerY - enemy.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 30) {
            enemy.x += (dx / distance) * enemy.speed;
            enemy.y += (dy / distance) * enemy.speed;
        }
        
        enemy.angle += 0.1;
        
        if (enemy.canShoot && distance < 350) {
            const now = Date.now();
            if (now - enemy.lastShot > 5000) {
                enemy.lastShot = now;
                const angle = Math.atan2(dy, dx);
                enemyBulletList.push({
                    x: enemy.x,
                    y: enemy.y,
                    vx: Math.cos(angle) * 4,
                    vy: Math.sin(angle) * 4
                });
                addParticles(enemy.x, enemy.y, '#e74c3c', 3);
            }
        }
        
        for (let i = bulletList.length - 1; i >= 0; i--) {
            const bullet = bulletList[i];
            const bdx = bullet.x - enemy.x;
            const bdy = bullet.y - enemy.y;
            const bdist = Math.sqrt(bdx * bdx + bdy * bdy);
            
            if (bdist < 20) {
                enemy.hp -= bullet.dmg;
                bulletList.splice(i, 1);
                playAudio('hit');
                addParticles(enemy.x, enemy.y, '#e74c3c', 8);
                screenShake = 2;
                
                if (enemy.hp <= 0) {
                    score += 10;
                    money += 5;
                    killCount++;
                    playAudio('kill');
                    addParticles(enemy.x, enemy.y, '#e74c3c', 20);
                    screenShake = 5;
                    updateDisplay();
                    
                    if (killCount >= 5) {
                        waveNum++;
                        killCount = 0;
                        updateDisplay();
                    }
                    
                    return false;
                }
            }
        }
        
        if (distance < 30) {
            health -= 0.3;
            screenShake = 6;
            
            // Red flash effect
            ctx.save();
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(0, 0, W, H);
            ctx.restore();
            
            updateDisplay();
            if (health <= 0) {
                gameOver();
                return false;
            }
        }
        
        // Draw enemy body with gradient
        const gradient = ctx.createRadialGradient(enemy.x, enemy.y, 5, enemy.x, enemy.y, 15);
        gradient.addColorStop(0, '#ff6b6b');
        gradient.addColorStop(1, '#c0392b');
        
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#e74c3c';
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(enemy.x, enemy.y, 15, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw spikes
        ctx.fillStyle = '#8b0000';
        for (let i = 0; i < 6; i++) {
            const spikeAngle = enemy.angle + (Math.PI * 2 * i) / 6;
            const spikeX = enemy.x + Math.cos(spikeAngle) * 12;
            const spikeY = enemy.y + Math.sin(spikeAngle) * 12;
            ctx.beginPath();
            ctx.arc(spikeX, spikeY, 3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Draw eyes
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(enemy.x - 5, enemy.y - 3, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(enemy.x + 5, enemy.y - 3, 3, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(enemy.x - 5 + (dx / distance) * 2, enemy.y - 3 + (dy / distance) * 2, 1.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(enemy.x + 5 + (dx / distance) * 2, enemy.y - 3 + (dy / distance) * 2, 1.5, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw gun for shooting enemies
        if (enemy.canShoot) {
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            const gunAngle = Math.atan2(dy, dx);
            ctx.beginPath();
            ctx.moveTo(enemy.x, enemy.y);
            ctx.lineTo(enemy.x + Math.cos(gunAngle) * 15, enemy.y + Math.sin(gunAngle) * 15);
            ctx.stroke();
        }
        
        ctx.shadowBlur = 0;
        
        // Health bar
        ctx.fillStyle = '#333';
        ctx.fillRect(enemy.x - 15, enemy.y - 25, 30, 3);
        ctx.fillStyle = '#2ecc71';
        ctx.fillRect(enemy.x - 15, enemy.y - 25, 30 * (enemy.hp / enemy.maxHp), 3);
        
        return true;
    });
    
    enemyBulletList = enemyBulletList.filter(b => {
        b.x += b.vx;
        b.y += b.vy;
        
        ctx.shadowBlur = 8;
        ctx.shadowColor = '#e74c3c';
        ctx.fillStyle = '#e74c3c';
        ctx.beginPath();
        ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        
        const dx = b.x - playerX;
        const dy = b.y - playerY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < 20) {
            health -= 8;
            playAudio('damage');
            addParticles(b.x, b.y, '#3498db', 10);
            screenShake = 4;
            updateDisplay();
            
            if (health <= 0) {
                gameOver();
                return false;
            }
            return false;
        }
        
        return b.x > -50 && b.x < W + 50 && b.y > -50 && b.y < H + 50;
    });
    
    drawParticles();
    
    ctx.shadowBlur = 12;
    ctx.shadowColor = '#3498db';
    ctx.fillStyle = '#3498db';
    ctx.beginPath();
    ctx.arc(playerX, playerY, 20, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
    
    if (aiming) {
        ctx.strokeStyle = '#f39c12';
        ctx.lineWidth = 2;
        ctx.shadowBlur = 8;
        ctx.shadowColor = '#f39c12';
        ctx.beginPath();
        ctx.moveTo(playerX, playerY);
        ctx.lineTo(playerX + aimDirX * 40, playerY + aimDirY * 40);
        ctx.stroke();
        ctx.shadowBlur = 0;
        
        ctx.fillStyle = '#f39c12';
        ctx.beginPath();
        ctx.arc(playerX + aimDirX * 40, playerY + aimDirY * 40, 4, 0, Math.PI * 2);
        ctx.fill();
    }
    
    ctx.restore();
    requestAnimationFrame(gameLoop);
}
</script>
</body>
</html>
                    
